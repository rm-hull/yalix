; Core yalix functions

(define (identity x)
  x)

(define (comp f g)
  (位 (x)
    (f (g x))))

(define (memoize f)
  (let* ((already-run? #f)
         (result nil))
    (位 ()
       (if (not already-run?)
         (begin
           (set! result (f))
           (set! already-run? #t)
           result)
         result))))

(define (force delayed-object)
  (if (if (atom? delayed-object) #t (nil? delayed-object))  ; OR .. need macros!
    delayed-object
    (delayed-object)))


(define (cons a b)
  (位 (index)
    (if index b a)))

(define (car xs)
  (if (not (nil? xs))
    (xs 0)))

(define (cdr xs)
  (if (not (nil? xs))
    (force (xs 1))))

(define first car)

(define next cdr)

(define rest cdr)

(define second (comp first next))

(define third (comp second next))

(define empty? nil?)

(define (dec n)
  (- n 1))

(define (inc n)
  (+ n 1))

(define (pos? n)
  (> n 0))

(define (zero? n)
  (= n 0))

(define (neg? n)
  (< n 0))

(define (iterate f x)
  (cons
    x
    (memoize 
      (delay 
        (iterate f (f x))))))

(define (range n)
  (take n (iterate inc 0)))

(define (map f xs)
  ;^ Maps a function over a list
  (if (empty? xs)
    nil
    (cons
      (f (first xs))
      (memoize 
        (delay 
          (map f (rest xs)))))))

(define (fold f val xs)
  (if (empty? xs)
    val
    (fold
      f
      (f val (first xs))
      (rest xs))))

(define (take n xs)
  (if (pos? n)
    (cons 
      (first xs)
      (memoize 
        (delay 
          (take (dec n) (rest xs)))))))

(define (drop n xs)
  (letrec ((step (位 (n xs)
                   (if (if (pos? n) (not (nil? xs)) #f)   ; AND ... Need macros! 
                     (step (dec n) (rest xs))             ; need tail-recursion here too
                     xs))))
    (if (pos? n)
      (step n xs))))

(define (nth xs index)
  (first (drop index xs)))

(define  (str . xs)
  (fold + "" xs))

(define (factorial n)
   ;^ The factorial of a non-negative integer n, denoted by n!, is
   ;^ the product of all positive integers less than or equal to n.
   (if (= n 0)
    1
    (* n (factorial (- n 1)))))

(define *print-item-limit* 
  ; cant add doc to primitive int
  55)

(define (lazy-list xs)
  (if (not (empty? xs))
    (cons
      (first xs)
      (memoize
        (delay
          (lazy-list (rest xs)))))))

(define (list . xs)
    (lazy-list xs))

; This is a comment

