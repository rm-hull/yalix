; Core yalix functions

(define (identity x)
  x)

(define (comp f g)
  (位 (x)
    (f (g x))))

(define (memoize f)
  (let* ((already-run? #f)
         (result nil))
    (位 ()
       (if (not already-run?)
         (begin
           (set! result (f))
           (set! already-run? #t)
           result)
         result))))

(define (force delayed-object)
  (if (if (atom? delayed-object) #t (nil? delayed-object))  ; OR .. need macros!
    delayed-object
    (delayed-object)))


(define (cons a b)
  (位 (index)
    (if index b a)))

(define (car xs)
  (if (not (nil? xs))
    (xs 0)))

(define (cdr xs)
  (if (not (nil? xs))
    (force (xs 1))))

(define first car)

(define next cdr)

(define rest cdr)

(define second (comp first next))

(define third (comp second next))

(define empty? nil?)

(define (dec n)
  (primitive-sub n 1))

(define (inc n)
  (primitive-add n 1))

(define (pos? n)
  (> n 0))

(define (zero? n)
  (= n 0))

(define (neg? n)
  (< n 0))

(define (iterate f x)
  (cons
    x
    (memoize 
      (delay 
        (iterate f (f x))))))

(define (range n)
  (take n (iterate inc 0)))

(define (map f xs)
  ;^ Maps a function over a list
  (if (empty? xs)
    nil
    (cons
      (f (first xs))
      (memoize 
        (delay 
          (map f (rest xs)))))))

(define (fold f val xs)
  (if (empty? xs)
    val
    (fold
      f
      (f val (first xs))
      (rest xs))))

(define (reductions f val xs)
  (cons 
    val
    (memoize
      (delay
        (if (not (empty? xs))
          (reductions f (f val (first xs)) (rest xs)))))))

(define (take n xs)
  (if (pos? n)
    (cons 
      (first xs)
      (memoize 
        (delay 
          (take (dec n) (rest xs)))))))

(define (drop n xs)
  (letrec ((step (位 (n xs)
                   (if (if (pos? n) (not (nil? xs)) #f)   ; AND ... Need macros! 
                     (step (dec n) (rest xs))             ; need tail-recursion here too
                     xs))))
    (if (pos? n)
      (step n xs))))

(define (nth xs index)
  (first (drop index xs)))

(define  (str . xs)
  (fold primitive-add "" xs))

(define (factorial n)
   ;^ The factorial of a non-negative integer n, denoted by n!, is
   ;^ the product of all positive integers less than or equal to n.
   (if (= n 0)
    1
    (* n (factorial (- n 1)))))

(define (lazy-list xs)
  (if (not (empty? xs))
    (cons
      (first xs)
      (memoize
        (delay
          (lazy-list (rest xs)))))))

(define (list . xs)
    (lazy-list xs))

; This is a comment

(define *print-length* 20)

(define (repr-list x n)
  ;^ turn a list into a string
  (if (not (nil? x))
    (if (pos? n)
      (if (cdr x)
        (str (repr (first x)) " " (repr-list (rest x) (dec n)))
        (repr (first x)))
      "...")))

(define (repr x)
  (if (atom? x)
    (repr-atom x)
    (str "(" (repr-list x *print-length*) ")")))

(define (+ . xs)
  ;^ Returns the sum of numbers. (+) returns 0.
  (fold primitive-add 0 xs))

(define (- x . xs)
  ;^ If just one argument is supplied, returns the negation of that value, 
  ;^ else subtracts the values successively. (-) returns 0.
  (if (empty? xs)
    (negate x)
    (fold primitive-sub x xs)))

(define (* . xs)
  ;^ Returns the product of the numbers. (*) returns 1.
  (fold primitive-mul 1 xs))

(define / primitive-div)
